"""
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.
조건 : 첫째 줄에 N(2<=n<=1000), M(1<=M<=10000), K(1<=K<=10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
       둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.
       입력으로 주어지는 K는 항상 M보다 작거나 같다.
       첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.
"""

# 조건에 의해 첫째 줄에 N, M, K의 자연수가 주어지고 공백으로 처리.
# 조건에 숫자의 구간이 설정되어 있는데 이 부분은 찾아보니 그냥 입력해줄 때에 조건이다.
# 1. map 을 통한 숫자 쪼개기 입력
#    split과 map 함수를 활용하여 숫자를 다중으로 입력.
#    map 함수는 map([적용할 함수],[적용할 값])으로 활용 가능
# 2. split 을 통한 쪼개기 입력
#    문자열.split([분류조건],[나눌횟수])를 통해 "list"로 return 한다.
#    split 파라미터를 기본으로 하면 공백을 기반으로 분리하여 return 한다.
# N, M, K 입력 받기
N, M, K = map(int, input().split())

# N개의 자연수 입력 받기
numbers = list(map(int, input().split()))

# 입력 받은 N개의 자연수 내림차순으로 정렬
numbers.sort(reverse=True)

# 내림차순으로 정렬된 숫자 중에서 1, 2번째 숫자 출력 (1, 2번째로 큰 숫자)
max_num = numbers[0]
second_max_num = numbers[1]

# 숫자의 주기 = (K + 1) --> 가장 큰 숫자가 최대 K번 반복할 수 있고 반복 후에 2번째로 큰 숫자가 최소 한 번 이어져야 하므로 K + 1
# (M // (K + 1)) --> 길이를 주기로 나누어서 몫을 구하면 반복 횟수를 구할 수 있다. 그리고 최대 K번 반복 할 수 있으므로 제일 큰 숫자의 총 반복 횟수는 (M // (K + 1)) * K 이다.
# M % (K + 1) --> 수열의 주기를 반복한 후 남은 나머지 숫자의 갯수
count = 0
count = (M // (K + 1)) * K + M % (K + 1)

# 숫자들의 합을 구할 result 변수 선언
result = 0

# (M - count) --> 총 숫자가 더해지는 횟수 = M 이므로 총 횟수에서 count 만큼 빼면 2번째로 큰 숫자의 반복 횟수.
result = max_num * count + second_max_num * (M - count)

print(result)



  